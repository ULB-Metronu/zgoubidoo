**********
Field maps
**********

This module allows creating field maps using symbolic expressions through the `sympy` library.
It is also possible to import field maps generated by `Opera`. This module generates a `Tosca` keyword with the path to
the file generated. The file can be written in a binary format to speed-up the simulation. Fitting methods are also
available to calculate the field decay based on an `Enge function`. The maps can be either a Cartesien of a Polar
field map; the user should adapt the parameters `MOD` and `MOD2` adequately. By default, the map is generated for the
mid-plane but it is possible to generate the expressions for the off-plane. The off-plane expressions are based on the
methods described in the report from `N.Tsoupas: Algorithm to calculate off-plane magnetic field from an on-plane field map`.

Cartesian field map
###################

The cartesian field map use `X, Y and Z` coordinates to generate the maps.

Rectangular bend
****************

The example here below generated the map for
a rectangular bend with pole face angle. Let's start with the usual imports:

.. jupyter-execute::

    import os
    import numpy as np
    import pandas as pd
    from itertools import product

    import sympy as sp
    from sympy import exp

    import zgoubidoo
    import zgoubidoo.vis
    from zgoubidoo.commands import *
    from zgoubidoo.fieldmaps import *
    from zgoubidoo import ureg as _ureg

We generated the `sympy` expressions that we will use to generate our maps:

.. jupyter-execute::

    B0 = sp.symbols('B0')
    k = sp.symbols('k')
    y = sp.symbols('y')
    y0 = sp.symbols('y0')
    g = sp.symbols('g')
    x = sp.symbols('x')

    d_e = sp.symbols('d_e')
    d_s = sp.symbols('d_s')
    xe = sp.symbols('xe')
    xs = sp.symbols('xs')
    xl = sp.symbols('xl')


    C = sp.IndexedBase('C')
    L = sp.symbols('L')
    i = sp.symbols('i', integer=True)

    # Enge function
    FE = 1 / (1 + sp.exp(sp.Sum(C[i] * (d_e/g)**i,(i,0,5))))
    FS = 1 / (1 + sp.exp(sp.Sum(C[i] * (d_s/g)**i,(i,0,5))))

    Bx = 0
    By = 0
    Bz = B0 * FE * FS
    Bz

Then, we define the extension and we replace the `sympy` expressions by their numerical values of our map.

.. jupyter-execute::

    kin = zgoubidoo.Kinematics(140 * _ureg.MeV)
    B1 = 0.05 * _ureg.T
    g_val= 0.15 *_ureg.m

    XL = 1 * _ureg.m
    WE = 50 * _ureg.degrees
    WS = 50 * _ureg.degrees

    XE = 2 * g_val
    XS = 2 * g_val

    x_val = np.linspace(0, XL.m_as('cm') + XE.m_as('cm') + XS.m_as('cm'), 201)
    y_val = np.linspace(-20, 20, 101)
    z_val = [0]

    mesh = np.array(list(product(x_val, y_val, z_val)))
    parameters_map = {
        g: g_val.m_as('cm'),
        C[0]: 0.1455,
        C[1]: 2.2670,
        C[2]: -0.6395,
        C[3]: 1.1558,
        C[4]: 0,
        C[5]: 0,
        d_e: (-(x - xe + y * np.tan(-WE.m_as('radians')))) * np.cos(WE.m_as('radians')),
        d_s: ((x - xl) - xe + y * np.tan(WS.m_as('radians'))) * np.cos(WS.m_as('radians')),
        B0: B1.m_as('kG'),
        xe: XE.m_as('cm'),
        xs: XS.m_as('cm'),
        xl: XL.m_as('cm')
    }

    Bz_val = Bz.doit().subs(parameters_map)

Now, we are ready to create our field map:

.. jupyter-execute::

    fm = CartesianFieldMap.generate_from_cartesian_expression(bx_expression=Bx,
                                                          by_expression=By,
                                                          bz_expression=Bz_val,
                                                          mesh=mesh)
    fmap = fm(label1='TOSCA_MAP', binary=False, MOD=0, MOD2=0, generator=ToscaCartesian2D, load_map=True)

.. note:: Before using the map in a line, you must load it. You can use the `load_map` argument or you can load it using
    `fmap.load()`

In the next notebooks, we use our map to track and plot the results:

.. jupyter-execute::
    :hide-code:

    zi = zgoubidoo.Input(name='SPIRAL', line=
               [BeamInputDistribution("BEAM", kinematics=kin),
                fmap,
               ])
    zi.XPAS = 1*_ureg.mm
    zi.survey(reference_frame=zgoubidoo.Frame(), with_reference_trajectory=True, reference_kinematics=kin);
    zi.IL = 2
    zr = zgoubidoo.Zgoubi()(zi).collect()


.. jupyter-execute::

    artist=zgoubidoo.vis.ZgoubidooPlotlyArtist()
    artist.fig['layout']['xaxis']['title'] = 'X (m)'
    artist.fig['layout']['yaxis']['title'] = 'Field (T)'
    artist.scatter(x=zr.tracks_frenet['X'][::5],
                   y=zr.tracks_frenet['BZ'][::5])
    artist.plot_cartouche(beamline=zi)
    artist.render()

.. jupyter-execute::

    artist=zgoubidoo.vis.ZgoubidooPlotlyArtist()
    artist.fig['layout']['xaxis']['title'] = 'X (m)'
    artist.fig['layout']['yaxis']['title'] = 'Y (m)'
    artist.scatter(x=zr.tracks_global['XG'][::5],
                   y=zr.tracks_global['YG'][::5])
    artist.plot_beamline(beamline=zi)
    artist.render()

Vertical Fixed-Field alternating gradient
*****************************************

.. automodule:: zgoubidoo.fieldmaps
    :members:

.. automodapi:: zgoubidoo.fieldmaps.fieldmap
    :no-heading:
